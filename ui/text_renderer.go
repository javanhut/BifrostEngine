package ui

import (
	"github.com/go-gl/gl/v4.1-core/gl"
)

type TextRenderer struct {
	shader  uint32
	vao     uint32
	vbo     uint32
	texture uint32
}

// Simple 8x8 bitmap font data for ASCII characters 32-126
var fontData = map[rune][8]byte{
	' ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	'A': {0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00},
	'B': {0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00},
	'C': {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00},
	'D': {0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00},
	'E': {0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00},
	'F': {0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00},
	'G': {0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00},
	'H': {0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00},
	'I': {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},
	'J': {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00},
	'K': {0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00},
	'L': {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00},
	'M': {0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00},
	'N': {0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00},
	'O': {0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00},
	'P': {0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00},
	'Q': {0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00},
	'R': {0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00},
	'S': {0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00},
	'T': {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00},
	'U': {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00},
	'V': {0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00},
	'W': {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},
	'X': {0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00},
	'Y': {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00},
	'Z': {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00},
	'a': {0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00},
	'b': {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00},
	'c': {0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00},
	'd': {0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00},
	'e': {0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00},
	'f': {0x0E, 0x18, 0x18, 0x3E, 0x18, 0x18, 0x18, 0x00},
	'g': {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C},
	'h': {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00},
	'i': {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00},
	'j': {0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x66, 0x3C},
	'k': {0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00},
	'l': {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},
	'm': {0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00},
	'n': {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00},
	'o': {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00},
	'p': {0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60},
	'q': {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06},
	'r': {0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00},
	's': {0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00},
	't': {0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x0E, 0x00},
	'u': {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00},
	'v': {0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00},
	'w': {0x00, 0x00, 0x63, 0x6B, 0x7F, 0x3E, 0x36, 0x00},
	'x': {0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00},
	'y': {0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x0C, 0x78},
	'z': {0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00},
	'0': {0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00},
	'1': {0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00},
	'2': {0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00},
	'3': {0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00},
	'4': {0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00},
	'5': {0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00},
	'6': {0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00},
	'7': {0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00},
	'8': {0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00},
	'9': {0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00},
	':': {0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00},
}

func NewTextRenderer() *TextRenderer {
	tr := &TextRenderer{}
	tr.setupShaders()
	tr.setupBuffers()
	return tr
}

func (tr *TextRenderer) setupShaders() {
	vertexShader := `
#version 330 core
layout (location = 0) in vec2 position;
layout (location = 1) in vec3 color;

out vec3 fragColor;

uniform mat4 projection;

void main() {
    gl_Position = projection * vec4(position, 0.0, 1.0);
    fragColor = color;
}
` + "\x00"

	fragmentShader := `
#version 330 core
in vec3 fragColor;
out vec4 FragColor;

void main() {
    FragColor = vec4(fragColor, 1.0);
}
` + "\x00"

	// Compile vertex shader
	vs := gl.CreateShader(gl.VERTEX_SHADER)
	csource, free := gl.Strs(vertexShader)
	gl.ShaderSource(vs, 1, csource, nil)
	free()
	gl.CompileShader(vs)

	// Compile fragment shader
	fs := gl.CreateShader(gl.FRAGMENT_SHADER)
	csource, free = gl.Strs(fragmentShader)
	gl.ShaderSource(fs, 1, csource, nil)
	free()
	gl.CompileShader(fs)

	// Create shader program
	tr.shader = gl.CreateProgram()
	gl.AttachShader(tr.shader, vs)
	gl.AttachShader(tr.shader, fs)
	gl.LinkProgram(tr.shader)

	gl.DeleteShader(vs)
	gl.DeleteShader(fs)
}

func (tr *TextRenderer) setupBuffers() {
	gl.GenVertexArrays(1, &tr.vao)
	gl.GenBuffers(1, &tr.vbo)
}

func (tr *TextRenderer) RenderText(text string, x, y float32, scale float32, color [3]float32, projection [16]float32) {
	gl.UseProgram(tr.shader)
	gl.BindVertexArray(tr.vao)

	// Set projection matrix
	projLocation := gl.GetUniformLocation(tr.shader, gl.Str("projection\x00"))
	gl.UniformMatrix4fv(projLocation, 1, false, &projection[0])

	charX := x
	charSize := 8.0 * scale

	for _, char := range text {
		if char == ' ' {
			charX += charSize
			continue
		}

		bitmap, exists := fontData[char]
		if !exists {
			bitmap = fontData['?'] // Use ? for unknown characters
		}

		tr.renderChar(bitmap, charX, y, scale, color)
		charX += charSize
	}
}

func (tr *TextRenderer) renderChar(bitmap [8]byte, x, y, scale float32, color [3]float32) {
	var vertices []float32
	pixelSize := scale

	// Flip the bitmap vertically by reading rows in reverse order
	for row := 7; row >= 0; row-- {
		for col := 0; col < 8; col++ {
			bit := (bitmap[row] >> (7 - col)) & 1
			if bit == 1 {
				// Calculate pixel position
				px := x + float32(col)*pixelSize
				py := y + float32(7-row)*pixelSize

				// Add quad vertices (2 triangles)
				vertices = append(vertices,
					// Triangle 1
					px, py, color[0], color[1], color[2],
					px+pixelSize, py, color[0], color[1], color[2],
					px, py+pixelSize, color[0], color[1], color[2],
					// Triangle 2
					px+pixelSize, py, color[0], color[1], color[2],
					px+pixelSize, py+pixelSize, color[0], color[1], color[2],
					px, py+pixelSize, color[0], color[1], color[2],
				)
			}
		}
	}

	if len(vertices) > 0 {
		gl.BindBuffer(gl.ARRAY_BUFFER, tr.vbo)
		gl.BufferData(gl.ARRAY_BUFFER, len(vertices)*4, gl.Ptr(vertices), gl.DYNAMIC_DRAW)

		// Position attribute
		gl.VertexAttribPointer(0, 2, gl.FLOAT, false, 5*4, gl.PtrOffset(0))
		gl.EnableVertexAttribArray(0)

		// Color attribute
		gl.VertexAttribPointer(1, 3, gl.FLOAT, false, 5*4, gl.PtrOffset(2*4))
		gl.EnableVertexAttribArray(1)

		gl.DrawArrays(gl.TRIANGLES, 0, int32(len(vertices)/5))
	}
}

func (tr *TextRenderer) Cleanup() {
	gl.DeleteVertexArrays(1, &tr.vao)
	gl.DeleteBuffers(1, &tr.vbo)
	gl.DeleteProgram(tr.shader)
}